#!/usr/bin/env bash

set -eE
failure() {
  local lineno=$1; local msg=$2
  echo "$(basename "$0"): failed at $lineno: $msg"
}
trap 'failure ${LINENO} "$BASH_COMMAND"' ERR

############### FUNCTIONS ###############
# Checks if the required tools have been installed
function check_tool() {
  local cmd=$1; local package=$2
  if ! command -v "$cmd" &>/dev/null; then
    >&2 echo "$cmd could not be found"; echo "Please install $package"; exit 1
  fi
}

# Prints the help message
function printHelp() {
  printf "Connects to a Private VPN server\n\n"
  printf "Usage: vpn [OPTIONS] [SERVER] [FLAGS]\n"
  printf "OPTIONS have to come before SERVER. FLAGS can be passed anywhere.\n"
  printf "It reads the username and password, for vpn authentication, from %s\n\n" "$AUTH"
  printf "OPTIONS:\n"
  printf "  %-7s   Connects to the specified server (or default one) with port forwarding if supported\n" "start"
  printf "  %-7s   Disconnects VPN\n" "stop"
  printf "  %-7s   (default) Check if VPN is connected\n" "status"
  printf "SERVER:\n"
  printf "  %-7s   (default) CA Vancouver\n" "van"
  printf "  %-7s   CA Ontario\n" "ont"
  printf "  %-7s   CA Montreal\n" "mtl"
  printf "  %-7s   CA Toronto\n" "tor"
  printf "  %-7s   DE Berlin\n" "ber"
  printf "  %-7s   DE Frankfurt\n" "frk"
  printf "  %-7s   France\n" "fra"
  printf "  %-7s   US Seattle\n" "sea"
  printf "FLAGS:\n"
  printf "  %-7s   Connects WITHOUT port forwarding\n" "-n"
  printf "  %-7s   Verbose output\n" "-v"
}

# Stops the VPN
function vpnStop() {
  if sudo ip -n "$NETNS_NAME" link show pia > /dev/null 2>&1; then
    sudo ip netns exec "$NETNS_NAME" wg-quick down pia > /dev/null 2>&1 # Stop VPN connection
    echo "VPN disconnected"
  else
    echo "Nothing to stop"
  fi

  sudo crontab -r > /dev/null 2>&1 || true # Remove port binding script
  DEBUG=$DEBUG $TRANSMISSION_STOP_SCRIPT # Stop Transmission
  DEBUG=$DEBUG NETNS_NAME=$NETNS_NAME $NAMESCAPE_DELETE # Delete namespace
}

# Retrieves the Public IP
# shellcheck disable=SC2120
function getIP() {
  local namespace=$1
  if [[ -n $namespace ]]; then
    sudo ip netns exec "$NETNS_NAME" dig TXT +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'"' '{ print $2}'
  else
    dig TXT +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'"' '{ print $2}'
  fi
}

############### CHECKS ###############
check_tool jq jq
check_tool dig dig
check_tool socat socat

# Analyze script options
while (( "$#" )); do
  case "$1" in
    -h|--help) printHelp; exit;;
    -v) DEBUG=true; shift;;
    -n) PIA_PF="false"; shift;;
    -*) # unsupported flags
      printf "\e[31m%s%s\e[0m\n" "Error: Unsupported flag " "$1"
      printHelp; exit 1;;
    *) # preserve positional arguments
      PARAMS+=("$1"); shift;;
  esac
done

# Checks for correct amount of parameters and assignes them
if (( ${#PARAMS[@]} > 2 )); then printf "\e[31m%s\e[0m\n" "A max of two parameters can be passed"; exit 1; fi
OPTIONS=${PARAMS[0]}
SERVER=${PARAMS[1]}

if [[ -n $DEBUG ]]; then
  echo "OPTIONS: $OPTIONS"
  echo "SERVER: $SERVER"
fi

############### VARIABLES ###############
WAIT_SECONDS=1 # seconds to wait before checking for updated IP
MAX_WAIT=12 # It'll wait for SEC times this value, i.e. SEC=5 MAX_WAIT=12, will wait for 1 minute
GEOIP=/home/felipe/.config/geoip/database/GeoLite2-City.mmdb # database for status info
AUTH_FILE=/home/felipe/.config/pia_vpn/passwd # PIA username and password
NETNS_NAME=piaVPN # name of the namespace

# Necessary scripts
SCRIPTS_DIR=/home/felipe/workspace/pia-vpn-transmission
VPN_START_SCRIPT=$SCRIPTS_DIR/get_token.sh
TRANSMISSION_START_SCRIPT=$SCRIPTS_DIR/start_transmission.sh
TRANSMISSION_STOP_SCRIPT=$SCRIPTS_DIR/stop_transmission.sh
NAMESCAPE_DELETE=$SCRIPTS_DIR/delete_namespace.sh
MMDBINSPECT=/home/felipe/go/bin/mmdbinspect

# Default to always forward port unless option to not do so was passed
[[ $PIA_PF != "false" ]] && PIA_PF="true"

# Assigns the correct server ID
case $SERVER in
  van | "") CITY="Vancouver, Canada"; SERVER_ID="ca_vancouver";;
  ont) CITY="Ontario, Canada"; SERVER_ID="ca_ontario";;
  mtl) CITY="Montreal, Canada"; SERVER_ID="ca";;
  tor) CITY="Toronto, Canada"; SERVER_ID="ca_toronto";;
  ber) CITY="Berlin, Germany"; SERVER_ID="ca_toronto";;
  frk) CITY="Frankfurt, Germany"; SERVER_ID="de-frankfurt";;
  fra) CITY="France"; SERVER_ID="france";;
  sea) CITY="Seattle, US"; SERVER_ID="us_seattle";;
  *) printf "\e[31m%s\e[0m\n" "Unrecognized server"; exit 1;;
esac

###########################################
case $OPTIONS in
  start)
    # Check if we should stop any existing connections
    if sudo ip -n "$NETNS_NAME" link show pia > /dev/null 2>&1; then
      read -r -n 1 -p "Do you want to stop the current connection before starting a new one? [Y/n] " stop
      [[ -n $stop ]] && printf "\n" # prints an emtpy line only when non-empty input
      stop=${stop:-y} # if empty, replace with 'y'
      if [[ $stop == "y" ]]; then vpnStop; else exit 0; fi
    fi

    IP=$(getIP) # Get IP before VPN
    if [[ -n $DEBUG ]]; then echo "IP before VPN: $IP"; fi
    VPN_IP="$IP" # Initiate the variable for while loop

    # Connects to the VPN
    DEBUG=$DEBUG SERVER_ID=$SERVER_ID AUTH_FILE=$AUTH_FILE PIA_PF=$PIA_PF NETNS_NAME=$NETNS_NAME $VPN_START_SCRIPT

    # Check and wait for new IP
    echo "Connected. Checking for new IP address...."
    count=1 # Doesn't let the while loop run forever
    while [[ $VPN_IP == "$IP" ]] && (( count <= MAX_WAIT )); do
      sleep $WAIT_SECONDS # Wait before checking for new IP
      VPN_IP=$(getIP true) # Get IP after VPN
      if [[ -n $DEBUG ]]; then printf "%d check for new IP\n" "$count"; fi
      (( count++ ))
    done

    if [[ $VPN_IP == "$IP" ]]; then
      echo "You're IP hasn't changed after $((MAX_WAIT * SEC)) seconds. Disconnecting VPN..."
      vpnStop
      exit
    fi

    echo "Connected to $CITY. Your new public IP is $VPN_IP"

    # Starts Transmission if port forwarding is enabled
    [[ $PIA_PF == "true" ]] && DEBUG=$DEBUG NETNS_NAME=$NETNS_NAME $TRANSMISSION_START_SCRIPT
    ;;
  stop)
    vpnStop
    ;;
  status | "")
    if ! sudo ip -n "$NETNS_NAME" link show pia > /dev/null 2>&1; then echo "VPN is disconnected"; exit; fi
    VPN_IP=$(getIP true)
    LOCATION=$($MMDBINSPECT -db $GEOIP "$VPN_IP" | jq '.[].Records[].Record | .city.names.en + " "  + .subdivisions[].iso_code  + ", " + .country.names.en')
    echo "Connected to $LOCATION. Your public IP is $VPN_IP"
    ;;
  *)
    printHelp
    ;;
esac
